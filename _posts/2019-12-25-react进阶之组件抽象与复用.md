---
layout: post
title: 'react进阶之组件抽象与复用'
date: '2019-09-24'
tags: 'react'
author: 'guozhaodong'
---

# react进阶之组件抽象与复用


### 关于组件抽象与复用

不管是什么应用、什么项目都需要对公共代码进行抽取，提取出公共的视图或行为逻辑，我们可称之为模块或组件。其对外部使用者来说是一个黑盒，不过可以通过提供的相关参数或接口进行调用。

抽取公共组件其实也是我们经常说的组件化、模块化开发的一部分。

`react`完全基于组件化开发，所以其组件化的程度会更高，对于项目中可复用的东西我们都可以将其抽取出来以方便我们的开发，对于开发效率的提升是可观的，同时对于项目后期的维护很有帮助。

### 抽取公共组件的注意点

在抽象公共功能时，要尽可能通用、灵活，高内聚、低藕合，对于React 组件可以总结出
下面一些经验和规则。

- 组件应该只通过属性输入，避免通过context，更要避免读取全局变量、系统1/0 等。
- 组件的属性应该有默认值，这样使用起来更简单，在大多数情况下不需要传递很多参数。
- 组件的属性应该使用简单值， 尽量避免使用对象等复杂的数据结构，简单的属性值更容
易理解和维护。
- 组件要足够健壮，考虑边界异常情况，要做好属性的类型验证， 不可缺省。
- 组件要有灵活的适用能力，不要限制使用环境，而要适用于一切环境， 比如组件不要给
自己设置宽度，要适用于所有的宽度。

### react公共组件封装方法

#### 嵌套

有时候组件内部是什么样子我们并不知道，只是外壳相同，这个时候你可以考虑使用组件的嵌套方式进行抽取。

`Panel`组件

![image](/assets/img/react-component/TM20190925162458.png)

``` JavaScript
let titleStr = null,
    extraStr = null;
if(this.props.title){
    titleStr = (
        <div className={cx("panel-title")}>
            {this.props.title}
        </div>
    )
}
if(this.props.extra){
    extraStr = (
        <div className={cx("panel-extra")}>
            {this.props.extra}
        </div>
    )
}
return (
    <div className={cx(['panel',this.props.className])}>
        {
            titleStr&&titleStr?(<div className={cx("panel-hd")}>
                {titleStr}
                {extraStr}
            </div>):null
        }
        <div className={cx("panel-bd")}>
            {this.props.children}
        </div>
    </div>
)


<Panel>
    面板主题内容
</Panel>
```

这种方式只使用组件级别的复用，对于逻辑代码段的复用没法实现，可以看下面的几种方式。

#### 组合与继承

react官网和社区推荐的方式都是组合，继承的话需要慎用，除非是不得不用的。

对于组件级别的复用，组合也就是把多个组件放在一起使用，形成一个功能更大的组件。


`ListOpeBar`列表页操作条组件，内部又包含了搜索`SuggestSearch`、`ExportButton`、`ImportGoodsPop`等等组件
``` JavaScript
<div
    className={cx("ope-bar") + " cf list-ope-bar"}
    style={{display: visible ? 'block' : 'none'}}
>
    <div className={cx("bar-left")}>
        {
            onSearch ? (
                <div className={cx("list-search")}>
                    <SuggestSearch
                        placeholder={searchPlaceHolder ? searchPlaceHolder : ''}
                        onSearch={onSearch}
                        defaultValue={defaultValue}
                        urlPrefix={this.props.searchTipsUrlPrefix ? this.props.searchTipsUrlPrefix : ''}
                        url={this.props.searchTipsUrl ? this.props.searchTipsUrl : ''}
                        ga-data={'batch-search'}
                    />
                </div>
            ) : null
        }
        {
            onFilter ? (
                <div className={cx("filter-btn-wrap")}>
                    <Button onClick={this.toggleFold} ga-data={'batch-filter-toggle'}><Icon type={'icon-filter'}/>{this.props.filterToolBarVisible?'收起':'展开'}筛选</Button>
                    <span className={cx(["icon-arrow", {"icon-arrow-fold": !this.props.filterToolBarVisible}])}><Icon type="up"/></span>
                </div>
            ) : null
        }
    </div>
    <div className={cx("bar-right")}>
        {
            component ? (
                <Button
                    ga-data={component.type + '-list'}
                    type={component.type} onClick={component.callback} icon={component.iconType}>
                    {component.text}</Button>
            ) : null
        }
        {
            onInvite ? (
                <Button
                    gadata={'batch-invite'}
                    type="default" module={this.props.authModule} icon={'user-add'} option={"add"}
                    onClick={this.props.openInviteModal}
                >
                    邀请注册
                </Button>
            ) : null
        }
        {
            exportType ? (
                <ExportButton
                    gadata={'batch-export-all'}
                    dataSource={exportDataSource} type={exportType} condition={exportCondition} beforeExport={beforeExport}/>
            ) : null
        }
        {
            miccnImportType ? (
                <ImportGoodsPop
                    gadata={'batch-import-miccn'}
                    option={"add"}  {...this.props} />
            ) : null
        }
        {
            importModule ? (
                <ImportButton
                    gadata={'batch-import'}
                    importModule={importModule} option={"add"} {...this.props} />
            ) : null
        }
        {
            showPrint && (
                <Button
                    ga-data={'batch-print'}
                    type='default' icon='printer' onClick={() => {
                    let bdHtml = window.document.body.innerHTML;
                    let printHtml = document.getElementById('printArea').innerHTML;
                    window.document.body.innerHTML = printHtml;
                    window.print();
                    window.document.body.innerHTML = bdHtml;
                    location.reload();
                }}>
                    打印
                </Button>
            )
        }
        {this.props.extraContent}
        {
            addUrl ? (
                <AddButton ga-data={'batch-add'} className="btn-list-add" module={this.props.authModule} type="primary" to={addUrl} icon="plus" label={addLabel}/>
            ) : null
        }
    </div>
</div>
```

对于逻辑代码的组合，在之前老版本的`react`使用`createClass`来创建组件中可以通过`mixins`功能对逻辑代码进行抽取。

 ``` JavaScript
import React from 'react'
import ReactDOM from 'react-dom'

const MouseMixin = {
  getInitialState() {
    return { x: 0, y: 0 }
  },

  handleMouseMove(event) {
    this.setState({
      x: event.clientX,
      y: event.clientY
    })
  }
}

const App = React.createClass({
  // Use the mixin!
  mixins: [ MouseMixin ],
  
  render() {
    const { x, y } = this.state

    return (
      <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>
        <h1>The mouse position is ({x}, {y})</h1>
      </div>
    )
  }
})
 ```


`es6` 通过`class`关键字来声明组件的方式逐渐取代了`createClass`的方式，在`react16`之后`mixin`方式不再被支持。

同时`mixins`方式也存在一些问题：

- 难以溯源，`mixins`修改`state`，在组件内部你无法知道`state`从哪来，尤其是有多个`mixins`的情况。
- 命名空间，多个`mixins`修改同一个`state`导致的命名冲突。

#### 高阶组件

不得不承认`react`社区确实很繁荣，高阶组件并不是`react api`的一部分，它是社区开发人员在长期开发中总结出来的一种复用组件逻辑的模式或者技巧。

其实它是借助了`js`中高阶函数的概念

高阶函数是一个函数，它接受函数作为参数或将函数作为输出返回。例如`Array.prototype.map`，`Array.prototype.filter`和`Array.prototype.reduce`是语言中内置的一些高阶函数，第三方的比如我们的防抖与节流，

```JavaScript
function debounce(func, wait = 300) {
  // 缓存一个定时器
  var timer;
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function(...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(function() {
      func.apply(this, args)
    }, wait)
  }
}


handleChange = debounce(()=>{
    console.log('用户输入了')   
})

<Input onChange={this.handleChange}/>
```


```JavaScript

function throttle(func, wait) {
    var context, args;
    var previous = 0;
 
    return function() {
        var now = +new Date();
        context = this;
        args = arguments;
        // 如果事件触发时等待时间超过了预设时间就执行一次
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}

window.onresize = throttle(function() {
    console.log ('resize execute');
})
```

下面我们来看下[高阶组件](https://bubble2.github.io/2018/10/26/react-hoc.html)

但是，回到之前`mixins`存在的问题，我们想一想，`HOC`有上述的问题么？我们来看下：

- 难以溯源，跟`mixins`不同的是，我们不再纠结`state`的源头，我们现在要纠结的是`HOC`的`props`里提供了些啥...
- 命名空间的冲突，这个问题依然存在，`props`里属性名可能会被多个`HOC`重复使用。


#### render prop`

`render prop`是在调用组件时，引入一个函数类型的prop ， 这个prop 定义了组件的渲染
方式。我认为其实就是父组件通过回调函数的方式获取子组件的状态的方式。

``` JavaScript

import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'

class Mouse extends React.Component {
  static propTypes = {
    render: PropTypes.func.isRequired
  }

  state = { x: 0, y: 0 }

  handleMouseMove = (event) => {
    this.setState({
      x: event.clientX,
      y: event.clientY
    })
  }

  render() {
    return (
      <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>
        {this.props.render(this.state)}
      </div>
    )
  }
}

const App = React.createClass({
  render() {
    return (
      <div style={{ height: '100%' }}>
        <Mouse render={({ x, y }) => (
          <h1>The mouse position is ({x}, {y})</h1>
        )}/>
        <Mouse>{({ x, y }) => (
          <h1>The mouse position is ({x}, {y})</h1>
        )}</Mouse>
      </div>
    )
  }
})
```

与高阶组件不同的是我们可以根据不同的状态在消费层面对组件的视图进行渲染。

这种方式可以解决前面`mixins`和`HOC`带来的问题。

但是这种方式有一个问题是：

this.props.render()或this.props.children()渲染的组件部分，我们难以直接使用
shouldComponnetUpdate（）来进行性能优化。因为在每次渲染周期中都声明了一个新的函数，在
使用shouldComponnetUpdate 进行props 浅比较时，都会永远返回true

为了解决这个问题，有时你可以定义一个 prop 作为实例方法，类似这样

``` JavaScript
renderMouse({X, Y}) {
  return <h1>The mouse position is ({x}, {y})</h1>;
}

  render() {
    return (
      <div>
        <h1>Move the mouse around!</h1>
        <Mouse render={this.renderMouse} />
      </div>
    );
  }
```









